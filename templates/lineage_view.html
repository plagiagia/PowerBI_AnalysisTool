{% extends "base.html" %} {% block title %}Data Lineage - Power BI Explorer{%
endblock %} {% block head %}
<!-- Include Vis Network CSS -->
<link href="https://unpkg.com/vis-network@9.1.2/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
<!-- Include FontAwesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
<!-- Include Showdown.js for Markdown to HTML conversion -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
<!-- Include AI features CSS -->
<link rel="stylesheet" href="{{ url_for('static', filename='lineage-ai.css') }}" />
{% endblock %} {% block breadcrumbs %}
<li>
  <a href="/lineage-view"><i class="fas fa-project-diagram"></i><span class="breadcrumb-text">Data Lineage</span></a>
</li>
{% endblock %} {% block content %}
<!-- Page Header -->
<div class="page-header">
  <h1 class="page-title">
    <i class="fas fa-project-diagram"></i> Measure Dependencies Diagram
  </h1>
  <p class="page-description">
    Visualize the relationships between measures and columns to understand data
    lineage.
  </p>
</div>

<!-- Layout with filters on left and diagram on right -->
<div class="lineage-layout">
  <!-- Left sidebar with controls -->
  <div class="lineage-controls">
    <!-- Filter Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-filter"></i> Filter</h2>
        <button class="panel-toggle" aria-label="Toggle filter panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="filter-group">
          <label for="measureSelect" class="filter-label">Select a Measure:</label>
          <div class="select-wrapper">
            <select id="measureSelect" class="filter-select">
              <option value="">All Measures</option>
              <!-- Options will be populated dynamically -->
            </select>
            <i class="fas fa-chevron-down"></i>
          </div>
        </div>

        <div class="filter-checkboxes">
          <div class="checkbox-group">
            <input type="checkbox" id="parentMeasures" class="custom-checkbox" checked />
            <label for="parentMeasures" class="checkbox-label">
              <span class="checkbox-icon parent-icon"></span>
              Parent Measures
            </label>
          </div>

          <div class="checkbox-group">
            <input type="checkbox" id="finalMeasures" class="custom-checkbox" checked />
            <label for="finalMeasures" class="checkbox-label">
              <span class="checkbox-icon final-icon"></span>
              Final Measures
            </label>
          </div>

          <div class="checkbox-group">
            <input type="checkbox" id="columns" class="custom-checkbox" checked />
            <label for="columns" class="checkbox-label">
              <span class="checkbox-icon column-icon"></span>
              Columns
            </label>
          </div>
        </div>
      </div>
    </div>

    <!-- Layout Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-sitemap"></i> Layout</h2>
        <button class="panel-toggle" aria-label="Toggle layout panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="radio-group">
          <input type="radio" id="hierarchical" name="layout" class="custom-radio" checked />
          <label for="hierarchical" class="radio-label">Hierarchical</label>
        </div>

        <div class="radio-group">
          <input type="radio" id="forceDirected" name="layout" class="custom-radio" />
          <label for="forceDirected" class="radio-label">Force Directed</label>
        </div>

        <div class="layout-actions">
          <button id="fitView" class="action-button secondary">
            <i class="fas fa-expand"></i> Fit View
          </button>
          <button id="resetView" class="action-button secondary">
            <i class="fas fa-undo"></i> Reset
          </button>
        </div>
      </div>
    </div>

    <!-- Stats Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-chart-pie"></i> Statistics</h2>
        <button class="panel-toggle" aria-label="Toggle stats panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="parentMeasureCount">0</div>
            <div class="stat-label">Parent Measures</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="finalMeasureCount">0</div>
            <div class="stat-label">Final Measures</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="columnCount">0</div>
            <div class="stat-label">Columns</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="relationshipCount">0</div>
            <div class="stat-label">Relationships</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Right content with network diagram -->
  <div class="lineage-content">
    <!-- Network Visualization -->
    <div class="network-container">
      <!-- Legend -->
      <div class="legend">
        <div class="legend-item">
          <span class="legend-color parent-color"></span>
          <span class="legend-label">Parent Measure</span>
        </div>
        <div class="legend-item">
          <span class="legend-color final-color"></span>
          <span class="legend-label">Final Measure</span>
        </div>
        <div class="legend-item">
          <span class="legend-color column-color"></span>
          <span class="legend-label">Column</span>
        </div>
      </div>

      <!-- Network diagram -->
      <div id="mynetwork" class="network-diagram" aria-label="Measure dependencies visualization"></div>

      <!-- Loading overlay -->
      <div id="networkLoading" class="network-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading diagram...</div>
      </div>

      <!-- Network controls -->
      <div class="network-controls">
        <button id="zoomIn" class="network-button" aria-label="Zoom in">
          <i class="fas fa-plus"></i>
        </button>
        <button id="zoomOut" class="network-button" aria-label="Zoom out">
          <i class="fas fa-minus"></i>
        </button>
        <button id="fullscreen" class="network-button" aria-label="Fullscreen">
          <i class="fas fa-expand-arrows-alt"></i>
        </button>
      </div>
    </div>

    <!-- Measure Details Panel -->
    <div class="measure-details">
      <div class="details-header">
        <h2 class="details-title">
          <i class="fas fa-calculator"></i> Measure Details
        </h2>
        <div class="details-actions">
          <div class="search-container compact">
            <div class="search-input-wrapper">
              <i class="fas fa-search"></i>
              <input type="search" id="searchMeasure" placeholder="Search in measure..."
                aria-label="Search measure definition" />
              <button id="clearMeasureSearch" class="clear-search" style="display: none" aria-label="Clear search">
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <button id="exportMeasure" class="action-button outline">
            <i class="fas fa-download"></i> Export
          </button>
        </div>
      </div>

      <div class="details-content">
        <!-- Measure card -->
        <div id="measureCard" class="measure-card">
          <!-- Measure header with metadata -->
          <div class="measure-card-header">
            <div class="measure-info">
              <h3 id="measureName" class="measure-name">Select a measure</h3>
              <div class="measure-meta">
                <span id="measureType" class="measure-type-badge">
                  <i class="fas fa-code-branch"></i> Type
                </span>
                <span id="measureReferences" class="measure-references">
                  <i class="fas fa-link"></i> <span id="referencesCount">0</span> References
                </span>
              </div>
            </div>
            <div class="measure-actions">
              <button id="copyMeasure" class="icon-button" title="Copy measure definition">
                <i class="fas fa-copy"></i>
              </button>
              <button id="expandCollapseAll" class="icon-button" title="Expand/collapse all">
                <i class="fas fa-expand-alt"></i>
              </button>
            </div>
          </div>

          <!-- Measure tabs -->
          <div class="measure-tabs">
            <button id="originalTab" class="measure-tab active">
              <i class="fas fa-code"></i> Original Definition
            </button>
            <button id="expandedTab" class="measure-tab">
              <i class="fas fa-expand"></i> Expanded Definition
            </button>
            <button id="optimizedTab" class="measure-tab">
              <i class="fas fa-magic"></i> Optimized
            </button>
            <button id="explanationTab" class="measure-tab">
              <i class="fas fa-book-open"></i> Explanation
            </button>
          </div>

          <!-- Measure content -->
          <div class="measure-content">
            <!-- Original definition tab content -->
            <div id="originalDefinition" class="tab-content active">
              <div class="code-container">
                <pre><code id="originalCode" class="language-dax">Select a measure to view its definition</code></pre>
              </div>
            </div>

            <!-- Expanded definition tab content -->
            <div id="expandedDefinition" class="tab-content">
              <div class="code-container">
                <pre><code id="expandedCode" class="language-dax">Select a measure to view its expanded definition</code></pre>
              </div>
            </div>
            
            <!-- Optimized definition tab content -->
            <div id="optimizedDefinition" class="tab-content">
              <div class="code-container">
                <pre><code id="optimizedCode" class="language-dax">Select a measure to view its optimized definition</code></pre>
              </div>
              <div class="ai-loading" id="optimizedLoading" style="display: none;">
                <div class="loading-spinner"></div>
                <div class="loading-text">AI is optimizing the measure...</div>
              </div>
            </div>
            
            <!-- Explanation tab content -->
            <div id="explanationDefinition" class="tab-content">
              <div class="explanation-container" id="explanationContent">
                <div class="placeholder-text">Select a measure to view its explanation</div>
              </div>
              <div class="ai-loading" id="explanationLoading" style="display: none;">
                <div class="loading-spinner"></div>
                <div class="loading-text">AI is generating explanation...</div>
              </div>
            </div>
          </div>

          <!-- Referenced measures section -->
          <div id="referencedMeasuresSection" class="referenced-measures-section">
            <h4 class="section-title">
              <i class="fas fa-link"></i> Referenced Measures
              <span class="section-count" id="referencedMeasuresCount">0</span>
            </h4>
            <div id="referencedMeasuresList" class="referenced-measures-list">
              <!-- Referenced measures will be populated by JavaScript -->
            </div>
          </div>
        </div>

        <!-- Empty state for when no measure is selected -->
        <div id="noMeasureSelected" class="empty-state">
          <div class="empty-state-icon">
            <i class="fas fa-calculator"></i>
          </div>
          <h3 class="empty-state-title">No measure selected</h3>
          <p class="empty-state-message">
            Select a measure in the diagram to view its details.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %} {% block scripts %}
<!-- Include Vis Network JS -->
<script src="https://unpkg.com/vis-network@9.1.2/standalone/umd/vis-network.min.js"></script>

<!-- Include AI features JS -->
<script src="{{ url_for('static', filename='lineage-ai.js') }}"></script>

<!-- Data for the network diagram -->
<script>
  // Declare the nodes and edges data for the network diagram
  const nodesArray = {{ nodes | tojson | safe }};
  const edgesArray = {{ edges | tojson | safe }};
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // DOM Elements
    const networkContainer = document.getElementById("mynetwork");
    const networkLoading = document.getElementById("networkLoading");
    const measureSelect = document.getElementById("measureSelect");
    const parentMeasuresCheck = document.getElementById("parentMeasures");
    const finalMeasuresCheck = document.getElementById("finalMeasures");
    const columnsCheck = document.getElementById("columns");
    const hierarchicalRadio = document.getElementById("hierarchical");
    const forceDirectedRadio = document.getElementById("forceDirected");
    const fitViewButton = document.getElementById("fitView");
    const resetViewButton = document.getElementById("resetView");
    const lineageTable = document.getElementById("lineageTable");
    const searchLineage = document.getElementById("searchLineage");
    const clearSearch = document.getElementById("clearSearch");
    const noDataMessage = document.getElementById("noDataMessage");
    const exportLineageButton = document.getElementById("exportLineage");
    const zoomInButton = document.getElementById("zoomIn");
    const zoomOutButton = document.getElementById("zoomOut");
    const fullscreenButton = document.getElementById("fullscreen");

    // Stats Elements
    const parentMeasureCount = document.getElementById("parentMeasureCount");
    const finalMeasureCount = document.getElementById("finalMeasureCount");
    const columnCount = document.getElementById("columnCount");
    const relationshipCount = document.getElementById("relationshipCount");

    // Panel toggles
    const panelToggles = document.querySelectorAll(".panel-toggle");

    // State variables
    let network = null;
    let isFullscreen = false;
    let currentSelection = null;
    let nodeDataset = null;
    let edgeDataset = null;

    // Create sets to track parentNodes, childNodes, finalNodes
    const parentNodeIds = new Set();
    const childNodeIds = new Set();
    const columnNodeIds = new Set();

    // Initialize the network with nodes and edges
    initializeNetwork();

    // Setup event listeners
    setupEventListeners();

    // Update statistics
    updateStatistics();

    /**
     * Initialize the network diagram
     */
    function initializeNetwork() {
      // Show loading indicator
      if (networkLoading) {
        networkLoading.style.display = "flex";
      }

      // Process nodes to identify types based on edges
      processNodesAndEdges();

      // Create datasets for nodes and edges
      nodeDataset = new vis.DataSet(nodesArray);
      edgeDataset = new vis.DataSet(edgesArray);

      // Network options
      const options = {
        nodes: {
          shape: "dot",
          size: 16,
          font: {
            size: 12,
            face: "Inter, Segoe UI, sans-serif"
          },
          borderWidth: 2,
          shadow: true
        },
        edges: {
          width: 1,
          color: {
            color: "#aaa",
            highlight: "#3498db"
          },
          arrows: {
            to: { enabled: true, scaleFactor: 0.5 }
          },
          smooth: {
            enabled: true,
            type: "dynamic",
            roundness: 0.5
          }
        },
        physics: {
          enabled: true,
          barnesHut: {
            gravitationalConstant: -2000,
            centralGravity: 0.1,
            springLength: 95,
            springConstant: 0.04,
            damping: 0.09
          },
          stabilization: {
            enabled: true,
            iterations: 1000,
            updateInterval: 100
          }
        },
        layout: {
          improvedLayout: true
        },
        interaction: {
          hover: true,
          tooltipDelay: 200,
          hideEdgesOnDrag: true,
          navigationButtons: false,
          keyboard: {
            enabled: true,
            speed: { x: 10, y: 10, zoom: 0.1 }
          },
          zoomView: true
        }
      };

      // Create the network
      const data = {
        nodes: nodeDataset,
        edges: edgeDataset
      };

      network = new vis.Network(networkContainer, data, options);

      // Apply hierarchical layout initially if selected
      if (hierarchicalRadio && hierarchicalRadio.checked) {
        applyHierarchicalLayout();
      }

      // Hide loading indicator when the network is stabilized
      network.on("stabilizationIterationsDone", function () {
        if (networkLoading) {
          networkLoading.style.display = "none";
        }
      });

      // Handle node selection for measure details
      network.on("selectNode", function (params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          currentSelection = nodeId;

          // Get the selected node
          const selectedNode = nodesArray.find(node => node.id === nodeId);

          // Only show measure details for non-column nodes
          if (selectedNode && selectedNode.type !== "column") {
            updateMeasureDetails(selectedNode);
          } else {
            // For columns, just show empty state
            hideMeasureDetails();
          }
        }
      });

      // Handle click on canvas (deselection)
      network.on("click", function (params) {
        if (params.nodes.length === 0) {
          // Clicked on empty space
          currentSelection = null;
          hideMeasureDetails();
        }
      });

      // Populate measure select options
      populateMeasureSelect();

      // Populate initial table with all relationships
      populateDetailsTable(edgesArray);
    }

    /**
     * Process nodes and edges to identify node types
     */
    function processNodesAndEdges() {
      // Identify parent and child nodes from edges
      edgesArray.forEach((edge) => {
        const fromId = edge.from;
        const toId = edge.to;

        parentNodeIds.add(fromId);
        childNodeIds.add(toId);
      });

      // Process nodes to set types and colors
      nodesArray.forEach((node) => {
        if (node.type === "column") {
          // Column node
          node.color = { background: "#ADD8E6", border: "#87CEEB" };
          node.shape = "box";
          columnNodeIds.add(node.id);
        } else if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
          // Pure parent - no parents of its own
          node.color = { background: "#F1C83B", border: "#DAA520" };
        } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Pure child - final measure
          node.color = { background: "#23C4A7", border: "#20B2AA" };
        } else if (parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Both parent and child - intermediate measure
          node.color = { background: "#F1C83B", border: "#DAA520" };
        } else {
          // Isolated node
          node.color = { background: "#CCCCCC", border: "#999999" };
        }
      });
    }

    /**
     * Set up event listeners for interactive elements
     */
    function setupEventListeners() {
      // Panel toggles
      if (panelToggles.length > 0) {
        panelToggles.forEach((toggle) => {
          toggle.addEventListener("click", function () {
            const panel = this.closest(".control-panel");
            panel.classList.toggle("collapsed");

            // Update toggle icon
            const icon = this.querySelector("i");
            if (panel.classList.contains("collapsed")) {
              icon.className = "fas fa-chevron-down";
            } else {
              icon.className = "fas fa-chevron-up";
            }
          });
        });
      }

      // Measure select dropdown
      if (measureSelect) {
        measureSelect.addEventListener("change", function () {
          filterByMeasure(this.value);
        });
      }

      // Filter checkboxes
      if (parentMeasuresCheck) {
        parentMeasuresCheck.addEventListener("change", applyFilters);
      }

      if (finalMeasuresCheck) {
        finalMeasuresCheck.addEventListener("change", applyFilters);
      }

      if (columnsCheck) {
        columnsCheck.addEventListener("change", applyFilters);
      }

      // Layout radio buttons
      if (hierarchicalRadio) {
        hierarchicalRadio.addEventListener("change", function () {
          if (this.checked) {
            applyHierarchicalLayout();
          }
        });
      }

      if (forceDirectedRadio) {
        forceDirectedRadio.addEventListener("change", function () {
          if (this.checked) {
            applyForceDirectedLayout();
          }
        });
      }

      // Fit view button
      if (fitViewButton) {
        fitViewButton.addEventListener("click", function () {
          if (network) {
            network.fit({
              animation: {
                duration: 1000,
                easingFunction: "easeInOutQuad",
              },
            });
          }
        });
      }

      // Reset view button
      if (resetViewButton) {
        resetViewButton.addEventListener("click", function () {
          resetView();
        });
      }

      // Search lineage
      if (searchLineage) {
        searchLineage.addEventListener("input", function () {
          const searchTerm = this.value.toLowerCase();

          // Show/hide clear button
          if (clearSearch) {
            clearSearch.style.display = searchTerm ? "block" : "none";
          }

          // Filter table rows
          filterDetailsTable(searchTerm);
        });
      }

      // Clear search button
      if (clearSearch) {
        clearSearch.addEventListener("click", function () {
          if (searchLineage) {
            searchLineage.value = "";
            searchLineage.focus();
            clearSearch.style.display = "none";

            // Show all rows
            filterDetailsTable("");
          }
        });
      }

      // Export lineage button
      if (exportLineageButton) {
        exportLineageButton.addEventListener("click", exportLineage);
      }

      // Zoom controls
      if (zoomInButton) {
        zoomInButton.addEventListener("click", function () {
          if (network) {
            const scale = network.getScale() * 1.2;
            network.moveTo({ scale: scale });
          }
        });
      }

      if (zoomOutButton) {
        zoomOutButton.addEventListener("click", function () {
          if (network) {
            const scale = network.getScale() / 1.2;
            network.moveTo({ scale: scale });
          }
        });
      }

      // Fullscreen button
      if (fullscreenButton) {
        fullscreenButton.addEventListener("click", toggleFullscreen);
      }
    }

    /**
     * Populate the measure select dropdown
     */
    function populateMeasureSelect() {
      if (!measureSelect) return;

      // Clear existing options (except the first one)
      while (measureSelect.options.length > 1) {
        measureSelect.remove(1);
      }

      // Create optgroups
      const parentGroup = document.createElement("optgroup");
      parentGroup.label = "Parent Measures";

      const finalGroup = document.createElement("optgroup");
      finalGroup.label = "Final Measures";

      const columnGroup = document.createElement("optgroup");
      columnGroup.label = "Columns";

      // Add nodes to respective groups
      nodesArray.forEach((node) => {
        const option = document.createElement("option");
        option.value = node.id;
        option.textContent = node.label;

        if (node.type === "column") {
          columnGroup.appendChild(option);
        } else if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
          // Pure parent
          parentGroup.appendChild(option);
        } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Pure child - final measure
          finalGroup.appendChild(option);
        } else {
          // Both parent and child - add to parent group
          parentGroup.appendChild(option);
        }
      });

      // Add groups to select element if they have options
      if (parentGroup.children.length > 0) {
        measureSelect.appendChild(parentGroup);
      }

      if (finalGroup.children.length > 0) {
        measureSelect.appendChild(finalGroup);
      }

      if (columnGroup.children.length > 0) {
        measureSelect.appendChild(columnGroup);
      }
    }

    /**
     * Filter network by selected measure
     * @param {string} measureId - ID of the selected measure
     */
    function filterByMeasure(measureId) {
      if (!network || !nodeDataset || !edgeDataset) return;

      if (!measureId) {
        // Reset to show all nodes and edges
        resetView();
        return;
      }

      // Find direct connections (one level)
      const connectedEdges = edgesArray.filter(
        (edge) => edge.from === measureId || edge.to === measureId
      );

      // Get connected node IDs
      const connectedNodeIds = new Set();
      connectedNodeIds.add(measureId); // Add the selected measure

      connectedEdges.forEach((edge) => {
        connectedNodeIds.add(edge.from);
        connectedNodeIds.add(edge.to);
      });

      // Update visibility of nodes
      nodeDataset.forEach((node) => {
        const isVisible = connectedNodeIds.has(node.id);
        const updates = { id: node.id, hidden: !isVisible };
        nodeDataset.update(updates);
      });

      // Update visibility of edges
      edgeDataset.forEach((edge) => {
        const isVisible =
          connectedNodeIds.has(edge.from) && connectedNodeIds.has(edge.to);
        const updates = { id: edge.id, hidden: !isVisible };
        edgeDataset.update(updates);
      });

      // Update details table with filtered edges
      populateDetailsTable(connectedEdges);

      // Fit view to show visible nodes
      if (network) {
        network.fit({
          animation: {
            duration: 1000,
            easingFunction: "easeInOutQuad",
          },
        });
      }
    }

    /**
     * Apply filters based on checkbox states
     */
    function applyFilters() {
      if (!network || !nodeDataset) return;

      const showParents = parentMeasuresCheck && parentMeasuresCheck.checked;
      const showFinal = finalMeasuresCheck && finalMeasuresCheck.checked;
      const showColumns = columnsCheck && columnsCheck.checked;

      // Update node visibility
      nodeDataset.forEach((node) => {
        let visible = true;

        if (node.type === "column") {
          visible = showColumns;
        } else if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
          // Pure parent
          visible = showParents;
        } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Pure child - final measure
          visible = showFinal;
        } else if (parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Both parent and child - consider it a parent for filtering
          visible = showParents;
        }

        nodeDataset.update({ id: node.id, hidden: !visible });
      });

      // Update edge visibility
      edgeDataset.forEach((edge) => {
        const fromNode = nodeDataset.get(edge.from);
        const toNode = nodeDataset.get(edge.to);

        const isVisible =
          fromNode && !fromNode.hidden && toNode && !toNode.hidden;

        edgeDataset.update({ id: edge.id, hidden: !isVisible });
      });

      // Update details table
      const visibleEdges = edgesArray.filter((edge) => {
        const fromNode = nodeDataset.get(edge.from);
        const toNode = nodeDataset.get(edge.to);

        return fromNode && !fromNode.hidden && toNode && !toNode.hidden;
      });

      populateDetailsTable(visibleEdges);
    }

    /**
     * Apply hierarchical layout
     */
    function applyHierarchicalLayout() {
      if (!network) return;

      network.setOptions({
        layout: {
          hierarchical: {
            enabled: true,
            direction: "LR", // Left to right
            sortMethod: "directed",
            levelSeparation: 150,
            nodeSpacing: 120,
          },
        },
      });
    }

    /**
     * Apply force-directed layout
     */
    function applyForceDirectedLayout() {
      if (!network) return;

      network.setOptions({
        layout: {
          hierarchical: {
            enabled: false,
          },
        },
        physics: {
          enabled: true,
          barnesHut: {
            gravitationalConstant: -2000,
            centralGravity: 0.1,
            springLength: 95,
            springConstant: 0.04,
            damping: 0.09,
          },
          stabilization: {
            enabled: true,
            iterations: 1000,
          },
        },
      });
    }

    /**
     * Reset the view to show all nodes and edges
     */
    function resetView() {
      if (!network || !nodeDataset || !edgeDataset) return;

      // Reset measure select
      if (measureSelect) {
        measureSelect.value = "";
      }

      // Reset filter checkboxes
      if (parentMeasuresCheck) {
        parentMeasuresCheck.checked = true;
      }

      if (finalMeasuresCheck) {
        finalMeasuresCheck.checked = true;
      }

      if (columnsCheck) {
        columnsCheck.checked = true;
      }

      // Show all nodes and edges
      nodeDataset.forEach((node) => {
        nodeDataset.update({ id: node.id, hidden: false });
      });

      edgeDataset.forEach((edge) => {
        edgeDataset.update({ id: edge.id, hidden: false });
      });

      // Reset selection
      currentSelection = null;

      // Restore all relationships in details table
      populateDetailsTable(edgesArray);

      // Fit view
      if (network) {
        network.fit({
          animation: {
            duration: 1000,
            easingFunction: "easeInOutQuad",
          },
        });
      }
    }

    /**
     * Update details table based on selected node
     * @param {string} nodeId - ID of the selected node
     */
    function updateDetailsTable(nodeId) {
      // Find connections related to this node
      const relatedEdges = edgesArray.filter(
        (edge) => edge.from === nodeId || edge.to === nodeId
      );

      // Populate table with these edges
      populateDetailsTable(relatedEdges);
    }

    /**
     * Populate the details table with edges
     * @param {Array} edges - Array of edges to display
     */
    function populateDetailsTable(edges) {
      if (!lineageTable) return;

      const tbody = lineageTable.querySelector("tbody");
      if (!tbody) return;

      // Clear existing rows
      tbody.innerHTML = "";

      // Show/hide empty state
      if (noDataMessage) {
        noDataMessage.style.display = edges.length === 0 ? "flex" : "none";
      }

      if (edges.length === 0) return;

      // Add rows for each edge
      edges.forEach((edge) => {
        const row = document.createElement("tr");

        // Get node objects
        const fromNode = nodesArray.find((n) => n.id === edge.from);
        const toNode = nodesArray.find((n) => n.id === edge.to);

        // Create cells
        const fromCell = document.createElement("td");
        const toCell = document.createElement("td");
        const columnCell = document.createElement("td");

        // Set content based on node types
        if (fromNode && fromNode.type === "column") {
          // This is a column-to-measure relationship
          fromCell.textContent = "";
          toCell.textContent = toNode ? toNode.label : "";
          columnCell.textContent = fromNode.label;

          // Add class to column name
          columnCell.classList.add("column-name");
        } else {
          // This is a measure-to-measure relationship
          fromCell.textContent = fromNode ? fromNode.label : "";
          toCell.textContent = toNode ? toNode.label : "";
          columnCell.textContent = "";

          // Add classes based on node types
          if (fromNode && parentNodeIds.has(fromNode.id)) {
            fromCell.classList.add("parent-measure");
          }

          if (toNode && !parentNodeIds.has(toNode.id)) {
            toCell.classList.add("final-measure");
          }
        }

        // Append cells to row
        row.appendChild(fromCell);
        row.appendChild(toCell);
        row.appendChild(columnCell);

        // Add row to table
        tbody.appendChild(row);
      });
    }

    /**
     * Filter the details table by search term
     * @param {string} term - Search term
     */
    function filterDetailsTable(term) {
      if (!lineageTable) return;

      const tbody = lineageTable.querySelector("tbody");
      if (!tbody) return;

      const rows = tbody.querySelectorAll("tr");
      let visibleCount = 0;

      rows.forEach((row) => {
        const text = row.textContent.toLowerCase();
        const isVisible = term === "" || text.includes(term);

        row.style.display = isVisible ? "" : "none";

        if (isVisible) {
          visibleCount++;

          // Highlight matching text if there's a search term
          if (term) {
            const cells = row.querySelectorAll("td");
            cells.forEach((cell) => {
              const originalText = cell.textContent;
              if (originalText.toLowerCase().includes(term)) {
                // Replace with highlighted version
                const regex = new RegExp(`(${escapeRegExp(term)})`, "gi");
                cell.innerHTML = originalText.replace(
                  regex,
                  '<span class="search-highlight">$1</span>'
                );
              }
            });
          }
        }
      });

      // Show/hide empty state
      if (noDataMessage) {
        noDataMessage.style.display = visibleCount === 0 ? "flex" : "none";
      }
    }

    /**
     * Escape special characters in string for regex
     * @param {string} string - String to escape
     * @returns {string} Escaped string
     */
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    /**
     * Export the lineage data
     */
    function exportLineage() {
      if (!lineageTable) return;

      // Get visible rows
      const tbody = lineageTable.querySelector("tbody");
      if (!tbody) return;

      const rows = Array.from(tbody.querySelectorAll("tr")).filter(
        (row) => row.style.display !== "none"
      );

      // Prepare CSV data
      const headers = ["Parent Measure", "Child Measure", "Column"];
      const csvRows = [headers.join(",")];

      rows.forEach((row) => {
        const cells = row.querySelectorAll("td");
        const values = Array.from(cells).map((cell) => {
          // Get text content without HTML
          let text = cell.textContent.trim();

          // Escape quotes and wrap in quotes if contains comma
          if (text.includes(",") || text.includes('"')) {
            text = '"' + text.replace(/"/g, '""') + '"';
          }

          return text;
        });

        csvRows.push(values.join(","));
      });

      // Create CSV content
      const csvContent = csvRows.join("\n");

      // Create and trigger download
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.setAttribute("href", url);
      link.setAttribute("download", "measure_lineage.csv");
      link.style.display = "none";
      document.body.appendChild(link);

      link.click();

      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      // Show notification
      if (window.PowerBIExplorer && window.PowerBIExplorer.showNotification) {
        window.PowerBIExplorer.showNotification(
          "Lineage data exported to CSV",
          "success"
        );
      }
    }

    /**
     * Toggle fullscreen mode for the network container
     */
    function toggleFullscreen() {
      const container = document.querySelector(".network-container");
      if (!container) return;

      if (!isFullscreen) {
        // Enter fullscreen
        container.classList.add("fullscreen");

        if (fullscreenButton) {
          fullscreenButton.innerHTML =
            '<i class="fas fa-compress-arrows-alt"></i>';
          fullscreenButton.setAttribute("aria-label", "Exit fullscreen");
        }

        isFullscreen = true;

        // Resize network after transition
        setTimeout(function () {
          if (network) {
            network.redraw();
            network.fit();
          }
        }, 300);
      } else {
        // Exit fullscreen
        container.classList.remove("fullscreen");

        if (fullscreenButton) {
          fullscreenButton.innerHTML =
            '<i class="fas fa-expand-arrows-alt"></i>';
          fullscreenButton.setAttribute("aria-label", "Fullscreen");
        }

        isFullscreen = false;

        // Resize network after transition
        setTimeout(() => {
          if (network) {
            network.redraw();
            network.fit();
          }
        }, 300);
      }
    }

    /**
     * Update statistics display
     */
    function updateStatistics() {
      // Count the different types of nodes
      let parentCount = 0;
      let finalCount = 0;
      let colCount = 0;

      nodesArray.forEach((node) => {
        if (node.type === "column") {
          colCount++;
        } else if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
          // Pure parent
          parentCount++;
        } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Pure child - final measure
          finalCount++;
        } else if (parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          // Both parent and child - count as parent
          parentCount++;
        }
      });

      // Update the statistics display
      if (parentMeasureCount) {
        parentMeasureCount.textContent = parentCount;
      }

      if (finalMeasureCount) {
        finalMeasureCount.textContent = finalCount;
      }

      if (columnCount) {
        columnCount.textContent = colCount;
      }

      if (relationshipCount) {
        relationshipCount.textContent = edgesArray.length;
      }

      // Add animation for statistics
      animateCounters();
    }

    /**
     * Animate the statistics counters
     */
    function animateCounters() {
      const counters = document.querySelectorAll(".stat-value");

      counters.forEach((counter) => {
        const target = parseInt(counter.textContent);
        let count = 0;
        const duration = 1500; // milliseconds
        const increment = target / (duration / 16); // 60 FPS

        const timer = setInterval(() => {
          count += increment;

          if (count >= target) {
            counter.textContent = target;
            clearInterval(timer);
          } else {
            counter.textContent = Math.floor(count);
          }
        }, 16);
      });
    }

    // Measure Details Card Functionality

    // DOM Elements for Measure Details
    const measureCard = document.getElementById("measureCard");
    const noMeasureSelected = document.getElementById("noMeasureSelected");
    const measureName = document.getElementById("measureName");
    const measureType = document.getElementById("measureType");
    const referencesCount = document.getElementById("referencesCount");
    const originalTab = document.getElementById("originalTab");
    const expandedTab = document.getElementById("expandedTab");
    const originalDefinition = document.getElementById("originalDefinition");
    const expandedDefinition = document.getElementById("expandedDefinition");
    const originalCode = document.getElementById("originalCode");
    const expandedCode = document.getElementById("expandedCode");
    const referencedMeasuresSection = document.getElementById("referencedMeasuresSection");
    const referencedMeasuresList = document.getElementById("referencedMeasuresList");
    const referencedMeasuresCount = document.getElementById("referencedMeasuresCount");
    const copyMeasure = document.getElementById("copyMeasure");
    const expandCollapseAll = document.getElementById("expandCollapseAll");
    const searchMeasure = document.getElementById("searchMeasure");
    const clearMeasureSearch = document.getElementById("clearMeasureSearch");
    const exportMeasure = document.getElementById("exportMeasure");

    // Set up event listeners for measure details
    if (originalTab) {
      originalTab.addEventListener("click", function () {
        window.LineageAI.switchTab("original");
      });
    }

    if (expandedTab) {
      expandedTab.addEventListener("click", function () {
        window.LineageAI.switchTab("expanded");
      });
    }

    if (copyMeasure) {
      copyMeasure.addEventListener("click", function () {
        copyMeasureDefinition();
      });
    }

    if (expandCollapseAll) {
      expandCollapseAll.addEventListener("click", function () {
        toggleExpandCollapse();
      });
    }

    if (searchMeasure) {
      searchMeasure.addEventListener("input", function () {
        searchInMeasure(this.value);
      });
    }

    if (clearMeasureSearch) {
      clearMeasureSearch.addEventListener("click", function () {
        if (searchMeasure) {
          searchMeasure.value = "";
          searchMeasure.focus();
          clearMeasureSearch.style.display = "none";
          searchInMeasure("");
        }
      });
    }

    if (exportMeasure) {
      exportMeasure.addEventListener("click", function () {
        exportMeasureDefinition();
      });
    }

    /**
     * Switch between tabs in the measure details card
     * @param {string} tabName - Name of the tab to switch to
     */
    function switchTab(tabName) {
      // Remove active class from all tabs and content
      originalTab.classList.remove("active");
      expandedTab.classList.remove("active");
      optimizedTab.classList.remove("active");
      explanationTab.classList.remove("active");
      
      originalDefinition.classList.remove("active");
      expandedDefinition.classList.remove("active");
      optimizedDefinition.classList.remove("active");
      explanationDefinition.classList.remove("active");
      
      // Add active class to selected tab and content
      if (tabName === "original") {
        originalTab.classList.add("active");
        originalDefinition.classList.add("active");
      } else if (tabName === "expanded") {
        expandedTab.classList.add("active");
        expandedDefinition.classList.add("active");
      } else if (tabName === "optimized") {
        optimizedTab.classList.add("active");
        optimizedDefinition.classList.add("active");
      } else if (tabName === "explanation") {
        explanationTab.classList.add("active");
        explanationDefinition.classList.add("active");
      }
    }
    
    /**
     * Load optimized definition using AI
     */
    function loadOptimizedDefinition() {
      if (!optimizedCode || !optimizedLoading || !measureName) return;
      
      const currentMeasureName = measureName.textContent;
      const daxExpression = originalCode.textContent;
      
      if (!daxExpression || daxExpression.includes("Select a measure")) {
        return;
      }
      
      // Show loading indicator
      optimizedLoading.style.display = "flex";
      optimizedCode.textContent = "Optimizing...";
      
      // Call the API to optimize the DAX
      fetch('/api/optimize-dax', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          dax: daxExpression,
          measureName: currentMeasureName
        }),
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        // Hide loading indicator
        optimizedLoading.style.display = "none";
        
        // Update the optimized code
        if (data.optimized_dax) {
          optimizedCode.textContent = data.optimized_dax;
        } else {
          optimizedCode.textContent = "Failed to optimize the measure.";
        }
      })
      .catch(error => {
        console.error('Error optimizing DAX:', error);
        optimizedLoading.style.display = "none";
        optimizedCode.textContent = "Error: Failed to optimize the measure. Please try again.";
      });
    }
    
    /**
     * Load explanation using AI
     */
    function loadExplanation() {
      if (!explanationContent || !explanationLoading || !measureName) return;
      
      const currentMeasureName = measureName.textContent;
      const daxExpression = originalCode.textContent;
      
      if (!daxExpression || daxExpression.includes("Select a measure")) {
        return;
      }
      
      // Show loading indicator
      explanationLoading.style.display = "flex";
      explanationContent.innerHTML = "<div class='loading-text'>Generating explanation...</div>";
      
      // Call the API to explain the DAX
      fetch('/api/explain-dax', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          dax: daxExpression,
          measureName: currentMeasureName
        }),
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        // Hide loading indicator
        explanationLoading.style.display = "none";
        
        // Update the explanation content
        if (data.explanation) {
          // Convert markdown to HTML
          const converter = new showdown.Converter();
          const html = converter.makeHtml(data.explanation);
          explanationContent.innerHTML = html;
        } else {
          explanationContent.innerHTML = "<div class='error-text'>Failed to generate explanation.</div>";
        }
      })
      .catch(error => {
        console.error('Error explaining DAX:', error);
        explanationLoading.style.display = "none";
        explanationContent.innerHTML = "<div class='error-text'>Error: Failed to generate explanation. Please try again.</div>";
      });
    }

    /**
     * Update the measure details card with the selected measure
     * @param {Object} node - The selected node
     */
    function updateMeasureDetails(node) {
      if (!measureCard || !noMeasureSelected) return;

      // Show measure card, hide empty state
      measureCard.style.display = "flex";
      noMeasureSelected.style.display = "none";

      // Update measure name
      if (measureName) {
        measureName.textContent = node.label;
      }

      // Determine measure type
      let type = "Unknown";
      let typeClass = "";

      if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
        // Pure parent
        type = "Parent Measure";
        typeClass = "parent";
      } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
        // Pure child - final measure
        type = "Final Measure";
        typeClass = "final";
      } else if (parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
        // Both parent and child
        type = "Parent Measure";
        typeClass = "parent";
      }

      // Update measure type badge
      if (measureType) {
        measureType.textContent = type;
        measureType.className = "measure-type-badge " + typeClass;
        measureType.innerHTML = `<i class="fas fa-code-branch"></i> ${type}`;
      }

      // Find referenced measures (parents)
      const parentEdges = edgesArray.filter(edge => edge.to === node.id);
      const parentNodes = parentEdges
        .map(edge => nodesArray.find(n => n.id === edge.from))
        .filter(n => n && n.type !== "column");

      // Find measures that reference this one (children)
      const childEdges = edgesArray.filter(edge => edge.from === node.id);
      const childNodes = childEdges
        .map(edge => nodesArray.find(n => n.id === edge.to))
        .filter(n => n);

      // Update references count
      const totalReferences = parentNodes.length + childNodes.length;
      if (referencesCount) {
        referencesCount.textContent = totalReferences;
      }

      // Update DAX code
      if (originalCode && node.dax) {
        originalCode.textContent = node.dax;
      }

      // Generate expanded definition
      if (expandedCode) {
        expandedCode.textContent = generateExpandedDefinition(node);
      }

      // Update referenced measures list
      if (referencedMeasuresList) {
        referencedMeasuresList.innerHTML = "";

        // Add parent measures
        parentNodes.forEach(parent => {
          const referenceElement = document.createElement("div");
          referenceElement.className = "measure-reference parent";
          referenceElement.textContent = parent.label;
          referenceElement.setAttribute("data-id", parent.id);
          referenceElement.addEventListener("click", function () {
            // Select this measure in the network
            if (network) {
              network.selectNodes([parent.id]);
              updateMeasureDetails(parent);
            }
          });
          referencedMeasuresList.appendChild(referenceElement);
        });

        // Add child measures
        childNodes.forEach(child => {
          const referenceElement = document.createElement("div");
          referenceElement.className = "measure-reference final";
          referenceElement.textContent = child.label;
          referenceElement.setAttribute("data-id", child.id);
          referenceElement.addEventListener("click", function () {
            // Select this measure in the network
            if (network) {
              network.selectNodes([child.id]);
              updateMeasureDetails(child);
            }
          });
          referencedMeasuresList.appendChild(referenceElement);
        });

        // Update count
        if (referencedMeasuresCount) {
          referencedMeasuresCount.textContent = parentNodes.length + childNodes.length;
        }

        // Show/hide referenced measures section
        if (referencedMeasuresSection) {
          referencedMeasuresSection.style.display =
            (parentNodes.length + childNodes.length) > 0 ? "block" : "none";
        }
      }
    }

    /**
     * Generate expanded definition by recursively replacing parent measure references
     * @param {Object} node - The measure node
     * @returns {string} Expanded definition
     */
    function generateExpandedDefinition(node) {
      if (!node || !node.dax) return "No definition available";

      let expandedDax = node.dax;

      // Find all parent measures
      const parentEdges = edgesArray.filter(edge => edge.to === node.id);
      const parentNodes = parentEdges
        .map(edge => nodesArray.find(n => n.id === edge.from))
        .filter(n => n && n.type !== "column");

      // Replace each parent measure reference with its definition
      parentNodes.forEach(parent => {
        // Simple replacement - in a real implementation, you would need more sophisticated
        // parsing to correctly identify and replace measure references
        const regex = new RegExp(`\\b${escapeRegExp(parent.label)}\\b`, "g");
        expandedDax = expandedDax.replace(regex, `/* ${parent.label} */ (${parent.dax})`);
      });

      return expandedDax;
    }

    /**
     * Hide measure details and show empty state
     */
    function hideMeasureDetails() {
      if (!measureCard || !noMeasureSelected) return;

      measureCard.style.display = "none";
      noMeasureSelected.style.display = "flex";
    }

    /**
     * Copy measure definition to clipboard
     */
    function copyMeasureDefinition() {
      const activeTab = document.querySelector(".measure-tab.active");
      let textToCopy = "";

      if (activeTab.id === "originalTab" && originalCode) {
        textToCopy = originalCode.textContent;
      } else if (activeTab.id === "expandedTab" && expandedCode) {
        textToCopy = expandedCode.textContent;
      }

      if (textToCopy) {
        navigator.clipboard.writeText(textToCopy).then(
          function () {
            // Show notification
            if (window.PowerBIExplorer && window.PowerBIExplorer.showNotification) {
              window.PowerBIExplorer.showNotification(
                "Measure definition copied to clipboard",
                "success"
              );
            }
          },
          function (err) {
            console.error("Could not copy text: ", err);
          }
        );
      }
    }

    /**
     * Toggle expand/collapse all in the expanded definition
     */
    function toggleExpandCollapse() {
      // This would be implemented for a more complex UI with collapsible sections
      // For now, we just toggle the icon
      if (expandCollapseAll) {
        const icon = expandCollapseAll.querySelector("i");
        if (icon.classList.contains("fa-expand-alt")) {
          icon.classList.remove("fa-expand-alt");
          icon.classList.add("fa-compress-alt");
          expandCollapseAll.setAttribute("title", "Collapse all");
        } else {
          icon.classList.remove("fa-compress-alt");
          icon.classList.add("fa-expand-alt");
          expandCollapseAll.setAttribute("title", "Expand all");
        }
      }
    }

    /**
     * Search within the measure definition
     * @param {string} term - Search term
     */
    function searchInMeasure(term) {
      // Show/hide clear button
      if (clearMeasureSearch) {
        clearMeasureSearch.style.display = term ? "block" : "none";
      }

      // Get active code element
      const activeTab = document.querySelector(".measure-tab.active");
      let codeElement = null;

      if (activeTab.id === "originalTab" && originalCode) {
        codeElement = originalCode;
      } else if (activeTab.id === "expandedTab" && expandedCode) {
        codeElement = expandedCode;
      }

      if (!codeElement) return;

      if (!term) {
        // Reset to original text without highlights
        codeElement.innerHTML = codeElement.textContent;
        return;
      }

      // Highlight matches
      const text = codeElement.textContent;
      const regex = new RegExp(`(${escapeRegExp(term)})`, "gi");
      codeElement.innerHTML = text.replace(
        regex,
        '<span class="search-highlight">$1</span>'
      );
    }

    /**
     * Export measure definition to a file
     */
    function exportMeasureDefinition() {
      const activeTab = document.querySelector(".measure-tab.active");
      let textToExport = "";
      let fileName = "";

      if (measureName) {
        fileName = measureName.textContent.replace(/\s+/g, "_") + ".dax";
      } else {
        fileName = "measure_definition.dax";
      }

      if (activeTab.id === "originalTab" && originalCode) {
        textToExport = originalCode.textContent;
      } else if (activeTab.id === "expandedTab" && expandedCode) {
        textToExport = expandedCode.textContent;
      }

      if (textToExport) {
        // Create and trigger download
        const blob = new Blob([textToExport], { type: "text/plain;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", fileName);
        link.style.display = "none";
        document.body.appendChild(link);

        link.click();

        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        // Show notification
        if (window.PowerBIExplorer && window.PowerBIExplorer.showNotification) {
          window.PowerBIExplorer.showNotification(
            "Measure definition exported to file",
            "success"
          );
        }
      }
    }
  });
</script>
{% endblock %}
