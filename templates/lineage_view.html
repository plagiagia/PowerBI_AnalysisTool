{% extends "base.html" %}
{% block title %}Data Lineage - Power BI Explorer{% endblock %}

{% block header_icon %}<i class="fas fa-project-diagram"></i>{% endblock %}
{% block header_title %}Data Lineage Diagram{% endblock %}
{% block header_subtitle %}Visualize complex relationships and dependencies between measures and columns to understand
data lineage{% endblock %}

{% block header_stats %}
<div class="quick-stat">
  <span class="stat-number" id="header-parent-measures">0</span>
  <span class="stat-label">Parent Measures</span>
</div>
<div class="quick-stat">
  <span class="stat-number" id="header-final-measures">0</span>
  <span class="stat-label">Final Measures</span>
</div>
<div class="quick-stat">
  <span class="stat-number" id="header-columns">0</span>
  <span class="stat-label">Columns</span>
</div>
{% endblock %}

{% block head %}
<!-- Include Vis Network CSS -->
<link href="https://unpkg.com/vis-network@9.1.2/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
<!-- Include FontAwesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
<style>
  /* Ensure network diagram container takes available space */
  .network-container {
    height: 70vh; /* Default height */
    background-color: var(--bg-primary); /* Adapts with theme */
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
  }

  .network-diagram {
    height: 100%;
    width: 100%;
  }
</style>
{% endblock %}

{% block breadcrumbs %}
<li>
  <a href="/lineage-view"><i class="fas fa-project-diagram"></i><span class="breadcrumb-text">Data Lineage</span></a>
</li>
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header">
  <h1 class="page-title">
    <i class="fas fa-project-diagram"></i> Measure Dependencies Diagram
  </h1>
  <p class="page-description">
    Visualize the relationships between measures and columns to understand data
    lineage.
  </p>
</div>

<!-- Layout with filters on left and diagram on right -->
<div class="lineage-layout">
  <!-- Left sidebar with controls -->
  <div class="lineage-controls">
    <!-- Filter Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-filter"></i> Filter</h2>
        <button class="panel-toggle" aria-label="Toggle filter panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="filter-group">
          <label for="measureSelect" class="filter-label">Select a Measure:</label>
          <div class="select-wrapper">
            <select id="measureSelect" class="filter-select">
              <option value="">All Measures</option>
              <!-- Options will be populated dynamically -->
            </select>
            <i class="fas fa-chevron-down"></i>
          </div>
        </div>

        <div class="filter-checkboxes">
          <div class="checkbox-group">
            <input type="checkbox" id="parentMeasures" class="custom-checkbox" checked />
            <label for="parentMeasures" class="checkbox-label">
              <span class="checkbox-icon parent-icon"></span>
              Parent Measures
            </label>
          </div>

          <div class="checkbox-group">
            <input type="checkbox" id="finalMeasures" class="custom-checkbox" checked />
            <label for="finalMeasures" class="checkbox-label">
              <span class="checkbox-icon final-icon"></span>
              Final Measures
            </label>
          </div>

          <div class="checkbox-group">
            <input type="checkbox" id="columns" class="custom-checkbox" checked />
            <label for="columns" class="checkbox-label">
              <span class="checkbox-icon column-icon"></span>
              Columns
            </label>
          </div>
        </div>
      </div>
    </div>

    <!-- Layout Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-sitemap"></i> Layout</h2>
        <button class="panel-toggle" aria-label="Toggle layout panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="radio-group">
          <input type="radio" id="hierarchical" name="layout" class="custom-radio" checked />
          <label for="hierarchical" class="radio-label">Hierarchical</label>
        </div>

        <div class="radio-group">
          <input type="radio" id="forceDirected" name="layout" class="custom-radio" />
          <label for="forceDirected" class="radio-label">Force Directed</label>
        </div>

        <div class="layout-actions">
          <button id="fitView" class="action-button secondary">
            <i class="fas fa-expand"></i> Fit View
          </button>
          <button id="resetView" class="action-button secondary">
            <i class="fas fa-undo"></i> Reset
          </button>
        </div>
      </div>
    </div>

    <!-- Stats Panel -->
    <div class="control-panel">
      <div class="panel-header">
        <h2 class="panel-title"><i class="fas fa-chart-pie"></i> Statistics</h2>
        <button class="panel-toggle" aria-label="Toggle stats panel">
          <i class="fas fa-chevron-up"></i>
        </button>
      </div>
      <div class="panel-content">
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="parentMeasureCount">0</div>
            <div class="stat-label">Parent Measures</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="finalMeasureCount">0</div>
            <div class="stat-label">Final Measures</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="columnCount">0</div>
            <div class="stat-label">Columns</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="relationshipCount">0</div>
            <div class="stat-label">Relationships</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Right content with network diagram -->
  <div class="lineage-content">
    <!-- Network Visualization -->
    <div class="network-container">
      <!-- Legend -->
      <div class="legend">
        <div class="legend-item">
          <span class="legend-color parent-color"></span>
          <span class="legend-label">Parent Measure</span>
        </div>
        <div class="legend-item">
          <span class="legend-color final-color"></span>
          <span class="legend-label">Final Measure</span>
        </div>
        <div class="legend-item">
          <span class="legend-color column-color"></span>
          <span class="legend-label">Column</span>
        </div>
      </div>

      <!-- Network diagram -->
      <div id="mynetwork" class="network-diagram" aria-label="Measure dependencies visualization"></div>

      <!-- Loading overlay -->
      <div id="networkLoading" class="network-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading diagram...</div>
      </div>

      <!-- Network controls -->
      <div class="network-controls">
        <button id="zoomIn" class="network-button" aria-label="Zoom in">
          <i class="fas fa-plus"></i>
        </button>
        <button id="zoomOut" class="network-button" aria-label="Zoom out">
          <i class="fas fa-minus"></i>
        </button>
        <button id="fullscreen" class="network-button" aria-label="Fullscreen">
          <i class="fas fa-expand-arrows-alt"></i>
        </button>
      </div>
    </div>

    <!-- Measure Details Panel -->
    <div class="measure-details">
      <div class="details-header">
        <h2 class="details-title">
          <i class="fas fa-calculator"></i> Measure Details
        </h2>
        <div class="details-actions">
          <div class="search-container compact">
            <div class="search-input-wrapper">
              <i class="fas fa-search"></i>
              <input type="search" id="searchMeasure" placeholder="Search in measure..."
                aria-label="Search measure definition" />
              <button id="clearMeasureSearch" class="clear-search" style="display: none" aria-label="Clear search">
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <button id="exportMeasure" class="action-button outline">
            <i class="fas fa-download"></i> Export
          </button>
        </div>
      </div>

      <div class="details-content">
        <!-- Measure card -->
        <div id="measureCard" class="measure-card">
          <!-- Measure header with metadata -->
          <div class="measure-card-header">
            <div class="measure-info">
              <h3 id="measureName" class="measure-name">Select a measure</h3>
              <div class="measure-meta">
                <span id="measureType" class="measure-type-badge">
                  <i class="fas fa-code-branch"></i> Type
                </span>
                <span id="measureReferences" class="measure-references">
                  <i class="fas fa-link"></i> <span id="referencesCount">0</span> References
                </span>
              </div>
            </div>
            <div class="measure-actions">
              <button id="copyMeasure" class="icon-button" title="Copy measure definition">
                <i class="fas fa-copy"></i>
              </button>
              <button id="expandCollapseAll" class="icon-button" title="Expand/collapse all">
                <i class="fas fa-expand-alt"></i>
              </button>
            </div>
          </div>

          <!-- Measure tabs -->
          <div class="measure-tabs">
            <button id="originalTab" class="measure-tab active">
              <i class="fas fa-code"></i> Original Definition
            </button>
            <button id="expandedTab" class="measure-tab">
              <i class="fas fa-expand"></i> Expanded Definition
            </button>
          </div>

          <!-- Measure content -->
          <div class="measure-content">
            <!-- Original definition tab content -->
            <div id="originalDefinition" class="tab-content active">
              <div class="code-container">
                <pre><code id="originalCode" class="language-dax">Select a measure to view its definition</code></pre>
              </div>
            </div>

            <!-- Expanded definition tab content -->
            <div id="expandedDefinition" class="tab-content">
              <div class="code-container">
                <pre><code id="expandedCode" class="language-dax">Select a measure to view its expanded definition</code></pre>
              </div>
            </div>

          </div>

          <!-- Referenced measures section -->
          <div id="referencedMeasuresSection" class="referenced-measures-section">
            <h4 class="section-title">
              <i class="fas fa-link"></i> Referenced Measures
              <span class="section-count" id="referencedMeasuresCount">0</span>
            </h4>
            <div id="referencedMeasuresList" class="referenced-measures-list">
              <!-- Referenced measures will be populated by JavaScript -->
            </div>
          </div>
        </div>

        <!-- Empty state for when no measure is selected -->
        <div id="noMeasureSelected" class="empty-state">
          <div class="empty-state-icon">
            <i class="fas fa-calculator"></i>
          </div>
          <h3 class="empty-state-title">No measure selected</h3>
          <p class="empty-state-message">
            Select a measure in the diagram to view its details.
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Include Vis Network JS -->
<script src="https://unpkg.com/vis-network@9.1.2/standalone/umd/vis-network.min.js"></script>


<!-- Data for the network diagram -->
<script>
  // Declare the nodes and edges data for the network diagram
  const nodesArray = {{ nodes | tojson | safe }};
  const edgesArray = {{ edges | tojson | safe }};
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    // DOM Elements
    const networkContainer = document.getElementById("mynetwork");
    const networkLoading = document.getElementById("networkLoading");
    const measureSelect = document.getElementById("measureSelect");
    const parentMeasuresCheck = document.getElementById("parentMeasures");
    const finalMeasuresCheck = document.getElementById("finalMeasures");
    const columnsCheck = document.getElementById("columns");
    const hierarchicalRadio = document.getElementById("hierarchical");
    const forceDirectedRadio = document.getElementById("forceDirected");
    const fitViewButton = document.getElementById("fitView");
    const resetViewButton = document.getElementById("resetView");
    // const lineageTable = document.getElementById("lineageTable"); // This element does not exist in the HTML
    const searchLineage = document.getElementById("searchLineage"); // This element also seems to be missing
    const clearSearch = document.getElementById("clearSearch"); // Missing
    // const noDataMessage = document.getElementById("noDataMessage"); // Missing
    // const exportLineageButton = document.getElementById("exportLineage"); // Missing
    const zoomInButton = document.getElementById("zoomIn");
    const zoomOutButton = document.getElementById("zoomOut");
    const fullscreenButton = document.getElementById("fullscreen");

    // Stats Elements
    const parentMeasureCount = document.getElementById("parentMeasureCount");
    const finalMeasureCount = document.getElementById("finalMeasureCount");
    const columnCount = document.getElementById("columnCount");
    const relationshipCount = document.getElementById("relationshipCount");

    // Panel toggles
    const panelToggles = document.querySelectorAll(".panel-toggle");

    // State variables
    let network = null;
    let isFullscreen = false;
    let currentSelection = null;
    let nodeDataset = null;
    let edgeDataset = null;

    // Create sets to track parentNodes, childNodes, finalNodes
    const parentNodeIds = new Set();
    const childNodeIds = new Set();
    const columnNodeIds = new Set();

    // Initialize the network with nodes and edges
    initializeNetwork(document.body.classList.contains('dark-mode'));

    // Setup event listeners
    setupEventListeners();

    // Update statistics
    updateStatistics();

    // Listen for theme changes from base.html
    document.addEventListener('themeChanged', function (event) {
      if (network) { // Check if network is initialized
        const isDarkMode = event.detail.theme === 'dark';
        const optionsToSet = getVisOptions(isDarkMode);
        network.setOptions(optionsToSet);

        // Update node colors directly as setOptions might not refresh them from dataset
        if (nodeDataset) {
          const allNodes = nodeDataset.get({ returnType: 'Array' });
          const updatedNodes = allNodes.map(node => {
            // Ensure node.nodeType is used, which is set in processNodesAndEdges
            const newColors = getNodeColor(node, isDarkMode);
            return { ...node, id: node.id, color: newColors }; // Ensure id is part of the update object
          });
          if (updatedNodes.length > 0) {
            nodeDataset.update(updatedNodes);
          }
        }
      }
    });

    function getCSSVariable(variableName, defaultValue = '#000000') {
      if (typeof window === 'undefined') return defaultValue; // Guard for server-side or pre-DOM environments
      const value = getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
      return value || defaultValue;
    }

    function getVisOptions(isDarkMode) {
      const commonNodeOptions = {
        shape: "dot",
        size: 16,
        borderWidth: 2,
        shadow: true,
      };

      const commonEdgeOptions = {
        width: 1,
        arrows: { to: { enabled: true, scaleFactor: 0.5 } },
        smooth: { enabled: true, type: "dynamic", roundness: 0.5 }
      };

      const commonInteractionOptions = {
        hover: true,
        tooltipDelay: 200,
        hideEdgesOnDrag: true,
        navigationButtons: false,
        keyboard: { enabled: true, speed: { x: 10, y: 10, zoom: 0.1 } },
        zoomView: true
      };

      const commonPhysicsOptions = {
        enabled: true,
        barnesHut: {
          gravitationalConstant: -2000,
          centralGravity: 0.1,
          springLength: 95,
          springConstant: 0.04,
          damping: 0.09
        },
        stabilization: {
          enabled: true,
          iterations: 1000,
          updateInterval: 50
        }
      };

      const commonLayoutOptions = {
        improvedLayout: true,
        // Hierarchical settings are applied conditionally in applyHierarchicalLayout / applyForceDirectedLayout
      };

      if (isDarkMode) {
        return {
          nodes: {
            ...commonNodeOptions,
            font: { size: 12, face: "Inter, Segoe UI, sans-serif", color: getCSSVariable('--text-primary', '#e0e0e0') }
          },
          edges: {
            ...commonEdgeOptions,
            color: {
              color: getCSSVariable('--gray-500', '#6f6f6f'),
              highlight: getCSSVariable('--primary-light', '#5fa0e6')
            }
          },
          physics: commonPhysicsOptions,
          layout: commonLayoutOptions,
          interaction: commonInteractionOptions,
          // Canvas background for Vis.js is typically handled by styling the container div.
          // Ensure #mynetwork or .network-container background is themed via CSS.
        };
      } else { // Light Mode
        return {
          nodes: {
            ...commonNodeOptions,
            font: { size: 12, face: "Inter, Segoe UI, sans-serif", color: getCSSVariable('--text-primary', '#212529') }
          },
          edges: {
            ...commonEdgeOptions,
            color: {
              color: "#aaa",
              highlight: "#3498db"
            }
          },
          physics: commonPhysicsOptions,
          layout: commonLayoutOptions,
          interaction: commonInteractionOptions
        };
      }
    }

    function getNodeColor(node, isDarkMode) {
      let baseColors;
      // node.type comes from backend (Python: self.nodes.append({'id': ..., 'type': 'column'})
      // node.nodeType is a JS-assigned property for more detailed classification.
      // Prefer node.nodeType if available, otherwise fallback to node.type for columns.
      const type = node.nodeType || (node.type === "column" ? "column" : "unknown");

      if (type === "column") {
        baseColors = isDarkMode ? { background: getCSSVariable('--accent', '#17a2b8'), border: getCSSVariable('--primary-dark', '#0052a3') }
          : { background: "#ADD8E6", border: "#87CEEB" };
      } else if (type === "parent") { // Pure parent or intermediate treated as parent for color
        baseColors = isDarkMode ? { background: getCSSVariable('--warning', '#ffc107'), border: getCSSVariable('--primary-dark', '#0052a3') }
          : { background: "#F1C83B", border: "#DAA520" };
      } else if (type === "final") { // Pure child
        baseColors = isDarkMode ? { background: getCSSVariable('--success', '#28a745'), border: getCSSVariable('--primary-dark', '#0052a3') }
          : { background: "#23C4A7", border: "#20B2AA" };
      } else if (type === "intermediate") { // Explicit intermediate if ever needed (currently same as parent)
        baseColors = isDarkMode ? { background: getCSSVariable('--warning', '#ffc107'), border: getCSSVariable('--primary-dark', '#0052a3') }
          : { background: "#F1C83B", border: "#DAA520" };
      } else { // Isolated or unknown
        baseColors = isDarkMode ? { background: getCSSVariable('--gray-600', '#495057'), border: getCSSVariable('--gray-700', '#343a40') }
          : { background: "#CCCCCC", border: "#999999" };
      }
      return baseColors;
    }

    /**
     * Initialize the network diagram
     */
    function initializeNetwork(isDarkMode) {
      if (networkLoading) {
        networkLoading.style.display = "flex";
      }

      processNodesAndEdges(isDarkMode);

      nodeDataset = new vis.DataSet(nodesArray);
      edgeDataset = new vis.DataSet(edgesArray);

      const options = getVisOptions(isDarkMode);

      const data = {
        nodes: nodeDataset,
        edges: edgeDataset
      };

      network = new vis.Network(networkContainer, data, options);

      if (hierarchicalRadio && hierarchicalRadio.checked) {
        applyHierarchicalLayout();
      } else if (forceDirectedRadio && forceDirectedRadio.checked) {
        // Ensure physics are enabled for force-directed if it was turned off after stabilization
        network.setOptions({ physics: { enabled: true } });
      }


      network.on("stabilizationIterationsDone", function () {
        if (networkLoading) {
          networkLoading.style.display = "none";
        }
        // Turn off physics after initial stabilization for performance if not hierarchical
        if (forceDirectedRadio && forceDirectedRadio.checked) {
          network.setOptions({ physics: { enabled: false } });
        }
      });

      network.on("selectNode", function (params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          currentSelection = nodeId;
          const selectedNode = nodeDataset.get(nodeId);
          if (selectedNode && selectedNode.nodeType !== "column") {
            updateMeasureDetails(selectedNode);
          } else {
            hideMeasureDetails();
          }
        }
      });

      network.on("click", function (params) {
        if (params.nodes.length === 0) {
          currentSelection = null;
          hideMeasureDetails();
        }
      });

      populateMeasureSelect();
      // populateDetailsTable(edgesArray); // This function seems to be missing from the provided HTML
    }

    /**
     * Process nodes and edges to identify node types
     */
    function processNodesAndEdges(isDarkMode) {
      edgesArray.forEach((edge) => {
        parentNodeIds.add(edge.from);
        childNodeIds.add(edge.to);
      });

      nodesArray.forEach((node) => {
        if (node.type === "column") {
          node.nodeType = "column";
          node.shape = "box";
          columnNodeIds.add(node.id);
        } else if (parentNodeIds.has(node.id) && !childNodeIds.has(node.id)) {
          node.nodeType = "parent";
        } else if (!parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          node.nodeType = "final";
        } else if (parentNodeIds.has(node.id) && childNodeIds.has(node.id)) {
          node.nodeType = "intermediate"; // Explicitly intermediate
        } else {
          node.nodeType = "isolated";
        }
        node.color = getNodeColor(node, isDarkMode);
      });
    }

    /**
     * Set up event listeners for interactive elements
     */
    function setupEventListeners() {
      if (panelToggles.length > 0) {
        panelToggles.forEach((toggle) => {
          toggle.addEventListener("click", function () {
            const panel = this.closest(".control-panel");
            panel.classList.toggle("collapsed");
            const icon = this.querySelector("i");
            if (panel.classList.contains("collapsed")) {
              icon.className = "fas fa-chevron-down";
            } else {
              icon.className = "fas fa-chevron-up";
            }
          });
        });
      }

      if (measureSelect) {
        measureSelect.addEventListener("change", function () {
          filterByMeasure(this.value);
        });
      }

      if (parentMeasuresCheck) parentMeasuresCheck.addEventListener("change", applyFilters);
      if (finalMeasuresCheck) finalMeasuresCheck.addEventListener("change", applyFilters);
      if (columnsCheck) columnsCheck.addEventListener("change", applyFilters);

      if (hierarchicalRadio) {
        hierarchicalRadio.addEventListener("change", function () {
          if (this.checked) applyHierarchicalLayout();
        });
      }

      if (forceDirectedRadio) {
        forceDirectedRadio.addEventListener("change", function () {
          if (this.checked) applyForceDirectedLayout();
        });
      }

      if (fitViewButton) {
        fitViewButton.addEventListener("click", function () {
          if (network) network.fit({ animation: { duration: 1000, easingFunction: "easeInOutQuad" } });
        });
      }

      if (resetViewButton) resetViewButton.addEventListener("click", resetView);

      // Search and export buttons for a details table that is not present in the provided HTML
      // if (searchLineage) { ... }
      // if (clearSearch) { ... }
      // if (exportLineageButton) { ... }


      if (zoomInButton) {
        zoomInButton.addEventListener("click", function () {
          if (network) network.moveTo({ scale: network.getScale() * 1.2 });
        });
      }

      if (zoomOutButton) {
        zoomOutButton.addEventListener("click", function () {
          if (network) network.moveTo({ scale: network.getScale() / 1.2 });
        });
      }

      if (fullscreenButton) fullscreenButton.addEventListener("click", toggleFullscreen);
    }

    /**
     * Populate the measure select dropdown
     */
    function populateMeasureSelect() {
      if (!measureSelect) return;
      while (measureSelect.options.length > 1) measureSelect.remove(1);

      const groups = {
        parent: document.createElement("optgroup"),
        final: document.createElement("optgroup"),
        column: document.createElement("optgroup"),
        intermediate: document.createElement("optgroup"), // For intermediate measures
        isolated: document.createElement("optgroup")    // For isolated measures
      };
      groups.parent.label = "Parent Measures";
      groups.final.label = "Final Measures";
      groups.column.label = "Columns";
      groups.intermediate.label = "Intermediate Measures";
      groups.isolated.label = "Isolated Measures";

      nodesArray.forEach((node) => {
        const option = document.createElement("option");
        option.value = node.id;
        option.textContent = node.label;
        // Use node.nodeType for grouping
        if (node.nodeType === "column") groups.column.appendChild(option);
        else if (node.nodeType === "parent") groups.parent.appendChild(option);
        else if (node.nodeType === "final") groups.final.appendChild(option);
        else if (node.nodeType === "intermediate") groups.intermediate.appendChild(option);
        else groups.isolated.appendChild(option);
      });

      for (const groupName in groups) {
        if (groups[groupName].children.length > 0) {
          measureSelect.appendChild(groups[groupName]);
        }
      }
    }

    /**
     * Filter network by selected measure
     */
    function filterByMeasure(measureId) {
      if (!network || !nodeDataset || !edgeDataset) return;
      if (!measureId) {
        resetView();
        return;
      }

      const connectedEdges = edgesArray.filter(edge => edge.from === measureId || edge.to === measureId);
      const connectedNodeIds = new Set([measureId]);
      connectedEdges.forEach(edge => {
        connectedNodeIds.add(edge.from);
        connectedNodeIds.add(edge.to);
      });

      const nodeUpdates = nodeDataset.map(node => ({ id: node.id, hidden: !connectedNodeIds.has(node.id) }));
      nodeDataset.update(nodeUpdates);

      const edgeUpdates = edgeDataset.map(edge => ({ id: edge.id, hidden: !(connectedNodeIds.has(edge.from) && connectedNodeIds.has(edge.to)) }));
      edgeDataset.update(edgeUpdates);

      // populateDetailsTable(connectedEdges); // Missing function/element
      if (network) network.fit({ animation: { duration: 1000, easingFunction: "easeInOutQuad" } });
    }

    /**
     * Apply filters based on checkbox states
     */
    function applyFilters() {
      if (!network || !nodeDataset) return;

      const showParents = parentMeasuresCheck && parentMeasuresCheck.checked;
      const showFinal = finalMeasuresCheck && finalMeasuresCheck.checked;
      const showColumns = columnsCheck && columnsCheck.checked;

      const nodeUpdates = nodeDataset.map((node) => {
        let visible = true;
        // Use node.nodeType for filtering decisions
        if (node.nodeType === "column") visible = showColumns;
        else if (node.nodeType === "parent" || node.nodeType === "intermediate") visible = showParents; // Treat intermediate as parent for this filter
        else if (node.nodeType === "final") visible = showFinal;
        // Isolated nodes visibility could be an option or tied to one of these
        return { id: node.id, hidden: !visible };
      });
      nodeDataset.update(nodeUpdates);

      const edgeUpdates = edgeDataset.map((edge) => {
        const fromNode = nodeDataset.get(edge.from);
        const toNode = nodeDataset.get(edge.to);
        const isVisible = fromNode && !fromNode.hidden && toNode && !toNode.hidden;
        return { id: edge.id, hidden: !isVisible };
      });
      edgeDataset.update(edgeUpdates);

      // const visibleEdges = edgesArray.filter(...); // Logic for visible edges based on nodeDataset
      // populateDetailsTable(visibleEdges); // Missing function/element
    }

    /**
     * Apply hierarchical layout
     */
    function applyHierarchicalLayout() {
      if (!network) return;
      network.setOptions({
        layout: {
          hierarchical: { enabled: true, direction: "LR", sortMethod: "directed", levelSeparation: 150, nodeSpacing: 120 }
        },
        physics: { enabled: false } // Typically disable physics for hierarchical
      });
    }

    /**
     * Apply force-directed layout
     */
    function applyForceDirectedLayout() {
      if (!network) return;
      network.setOptions({
        layout: { hierarchical: { enabled: false } },
        physics: {
          enabled: true,
          stabilization: { enabled: true, iterations: 1000 } // Re-enable stabilization
        }
      });
      // Turn off physics after stabilization
      network.once("stabilizationIterationsDone", function () {
        network.setOptions({ physics: { enabled: false } });
      });
    }

    /**
     * Reset the view to show all nodes and edges
     */
    function resetView() {
      if (!network || !nodeDataset || !edgeDataset) return;
      if (measureSelect) measureSelect.value = "";
      if (parentMeasuresCheck) parentMeasuresCheck.checked = true;
      if (finalMeasuresCheck) finalMeasuresCheck.checked = true;
      if (columnsCheck) columnsCheck.checked = true;

      const nodeUpdates = nodeDataset.map(node => ({ id: node.id, hidden: false }));
      nodeDataset.update(nodeUpdates);
      const edgeUpdates = edgeDataset.map(edge => ({ id: edge.id, hidden: false }));
      edgeDataset.update(edgeUpdates);

      currentSelection = null;
      hideMeasureDetails();
      // populateDetailsTable(edgesArray); // Missing
      if (network) network.fit({ animation: { duration: 1000, easingFunction: "easeInOutQuad" } });
      if (hierarchicalRadio && hierarchicalRadio.checked) applyHierarchicalLayout(); else applyForceDirectedLayout();
    }

    /**
     * Populate the details table with edges - Placeholder as element is missing
     * @param {Array} edges - Array of edges to display
     */
    function populateDetailsTable(edges) {
      // const lineageTable = document.getElementById("lineageTable"); // Element doesn't exist
      // if (!lineageTable) return;
      // ...
    }

    /**
     * Filter the details table by search term - Placeholder
     */
    function filterDetailsTable(term) {
      // const lineageTable = document.getElementById("lineageTable");
      // if (!lineageTable) return;
      // ...
    }

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    /**
     * Export the lineage data - Placeholder
     */
    function exportLineage() {
      // const lineageTable = document.getElementById("lineageTable");
      // if (!lineageTable) return;
      // ...
    }

    /**
     * Toggle fullscreen mode for the network container
     */
    function toggleFullscreen() {
      const container = document.querySelector(".network-container");
      if (!container) return;
      isFullscreen = !isFullscreen;
      if (isFullscreen) {
        container.classList.add("fullscreen");
        if (fullscreenButton) {
          fullscreenButton.innerHTML = '<i class="fas fa-compress-arrows-alt"></i>';
          fullscreenButton.setAttribute("aria-label", "Exit fullscreen");
        }
      } else {
        container.classList.remove("fullscreen");
        if (fullscreenButton) {
          fullscreenButton.innerHTML = '<i class="fas fa-expand-arrows-alt"></i>';
          fullscreenButton.setAttribute("aria-label", "Fullscreen");
        }
      }
      setTimeout(() => { if (network) { network.redraw(); network.fit(); } }, 300);
    }

    /**
     * Update statistics display
     */
    function updateStatistics() {
      let parentCount = 0, finalCount = 0, colCount = 0, intermediateCount = 0;
      nodesArray.forEach(node => {
        // Use node.nodeType which is set in processNodesAndEdges
        if (node.nodeType === "column") colCount++;
        else if (node.nodeType === "parent") parentCount++;
        else if (node.nodeType === "final") finalCount++;
        else if (node.nodeType === "intermediate") intermediateCount++; // Count intermediate
      });
      // Parents in stats might include intermediate ones for simplicity or show them separately
      if (parentMeasureCount) parentMeasureCount.textContent = parentCount + intermediateCount; // Or just parentCount
      if (finalMeasureCount) finalMeasureCount.textContent = finalCount;
      if (columnCount) columnCount.textContent = colCount;
      if (relationshipCount) relationshipCount.textContent = edgesArray.length;
      animateCounters();
    }

    /**
     * Animate the statistics counters
     */
    function animateCounters() {
      const counters = document.querySelectorAll(".stat-value");
      counters.forEach(counter => {
        const target = parseInt(counter.textContent);
        counter.textContent = '0'; // Start from 0 for animation
        let count = 0;
        const duration = 1500;
        const increment = target / (duration / 16);
        const timer = setInterval(() => {
          count += increment;
          if (count >= target) {
            counter.textContent = target;
            clearInterval(timer);
          } else {
            counter.textContent = Math.floor(count);
          }
        }, 16);
      });
    }

    // Measure Details Card Functionality (mostly unchanged but ensure elements exist)
    const measureCard = document.getElementById("measureCard");
    const noMeasureSelected = document.getElementById("noMeasureSelected");
    const measureNameEl = document.getElementById("measureName"); // Renamed to avoid conflict
    const measureTypeEl = document.getElementById("measureType"); // Renamed
    const referencesCountEl = document.getElementById("referencesCount"); // Renamed
    const originalTab = document.getElementById("originalTab");
    const expandedTab = document.getElementById("expandedTab");
    const originalDefinition = document.getElementById("originalDefinition");
    const expandedDefinition = document.getElementById("expandedDefinition");
    const originalCode = document.getElementById("originalCode");
    const expandedCode = document.getElementById("expandedCode");
    const referencedMeasuresSection = document.getElementById("referencedMeasuresSection");
    const referencedMeasuresList = document.getElementById("referencedMeasuresList");
    const referencedMeasuresCount = document.getElementById("referencedMeasuresCount");
    const copyMeasure = document.getElementById("copyMeasure");
    const expandCollapseAll = document.getElementById("expandCollapseAll");
    const searchMeasure = document.getElementById("searchMeasure");
    const clearMeasureSearch = document.getElementById("clearMeasureSearch");
    const exportMeasure = document.getElementById("exportMeasure");

    if (originalTab) originalTab.addEventListener("click", () => switchTab("original"));
    if (expandedTab) expandedTab.addEventListener("click", () => switchTab("expanded"));
    if (copyMeasure) copyMeasure.addEventListener("click", copyMeasureDefinition);
    if (expandCollapseAll) expandCollapseAll.addEventListener("click", toggleExpandCollapse);
    if (searchMeasure) searchMeasure.addEventListener("input", (e) => searchInMeasure(e.target.value));
    if (clearMeasureSearch) {
      clearMeasureSearch.addEventListener("click", () => {
        if (searchMeasure) {
          searchMeasure.value = "";
          searchMeasure.focus();
          clearMeasureSearch.style.display = "none";
          searchInMeasure("");
        }
      });
    }
    if (exportMeasure) exportMeasure.addEventListener("click", exportMeasureDefinition);

    function updateMeasureDetails(node) {
      if (!measureCard || !noMeasureSelected) return;
      measureCard.style.display = "flex";
      noMeasureSelected.style.display = "none";

      if (measureNameEl) measureNameEl.textContent = node.label;

      let typeText = "Unknown", typeClass = "unknown";
      // Use node.nodeType for type display
      if (node.nodeType === "parent") { typeText = "Parent Measure"; typeClass = "parent"; }
      else if (node.nodeType === "final") { typeText = "Final Measure"; typeClass = "final"; }
      else if (node.nodeType === "intermediate") { typeText = "Intermediate Measure"; typeClass = "parent"; } // Style as parent
      else if (node.nodeType === "column") { typeText = "Column"; typeClass = "column"; }


      if (measureTypeEl) {
        measureTypeEl.textContent = typeText;
        measureTypeEl.className = "measure-type-badge " + typeClass;
        measureTypeEl.innerHTML = `<i class="fas fa-code-branch"></i> ${typeText}`;
      }

      const parentEdges = edgesArray.filter(edge => edge.to === node.id);
      const parentNodes = parentEdges.map(edge => nodeDataset.get(edge.from)).filter(n => n && n.nodeType !== "column");
      const childEdges = edgesArray.filter(edge => edge.from === node.id);
      const childNodes = childEdges.map(edge => nodeDataset.get(edge.to)).filter(n => n);
      const totalRefs = parentNodes.length + childNodes.length;
      if (referencesCountEl) referencesCountEl.textContent = totalRefs;

      if (originalCode && node.dax) originalCode.textContent = node.dax; else if (originalCode) originalCode.textContent = "N/A";
      if (expandedCode) expandedCode.textContent = generateExpandedDefinition(node); else if (expandedCode) expandedCode.textContent = "N/A";



      if (referencedMeasuresList) {
        referencedMeasuresList.innerHTML = "";
        parentNodes.forEach(parent => appendReferencedMeasure(parent, "parent", referencedMeasuresList));
        childNodes.forEach(child => appendReferencedMeasure(child, child.nodeType === "final" ? "final" : "intermediate", referencedMeasuresList)); // Adjust class based on child's actual type
        if (referencedMeasuresCount) referencedMeasuresCount.textContent = totalRefs;
        if (referencedMeasuresSection) referencedMeasuresSection.style.display = totalRefs > 0 ? "block" : "none";
      }
    }

    function appendReferencedMeasure(node, typeClass, listElement) {
      const refEl = document.createElement("div");
      refEl.className = `measure-reference ${typeClass}`;
      refEl.textContent = node.label;
      refEl.setAttribute("data-id", node.id);
      refEl.addEventListener("click", function () {
        if (network) {
          network.selectNodes([node.id], { highlightEdges: false });
          // Need to ensure the node object passed to updateMeasureDetails is from nodeDataset
          const fullNodeObject = nodeDataset.get(node.id);
          if (fullNodeObject) updateMeasureDetails(fullNodeObject);
        }
      });
      listElement.appendChild(refEl);
    }


    function generateExpandedDefinition(node) {
      if (!node || !node.dax) return "No definition available";
      let expandedDax = node.dax;
      const parentEdges = edgesArray.filter(edge => edge.to === node.id);
      const parentNodes = parentEdges.map(edge => nodeDataset.get(edge.from)).filter(n => n && n.nodeType !== "column");
      parentNodes.forEach(parent => {
        const regex = new RegExp(`\\[${escapeRegExp(parent.label)}\\]|\\b${escapeRegExp(parent.label)}\\b(?!=[\(\"\'\\w])`, "g");
        expandedDax = expandedDax.replace(regex, `/* ${parent.label} */ (${parent.dax || "N/A"})`);
      });
      return expandedDax;
    }

    function hideMeasureDetails() {
      if (!measureCard || !noMeasureSelected) return;
      measureCard.style.display = "none";
      noMeasureSelected.style.display = "flex";
    }

    function copyMeasureDefinition() {
      const activeTab = document.querySelector(".measure-tabs .active"); // More specific selector
      let textToCopy = "";
      if (!activeTab) return;

      if (activeTab.id === "originalTab" && originalCode) textToCopy = originalCode.textContent;
      else if (activeTab.id === "expandedTab" && expandedCode) textToCopy = expandedCode.textContent;
      else if (activeTab.id === "optimizedTab" && document.getElementById("optimizedCode")) textToCopy = document.getElementById("optimizedCode").textContent;


      if (textToCopy && textToCopy !== "Select a measure to view its definition" && textToCopy !== "Optimizing..." && textToCopy !== "Select a measure to view its optimized definition") {
        navigator.clipboard.writeText(textToCopy).then(
          () => window.PowerBIExplorer && window.PowerBIExplorer.showNotification("Definition copied", "success"),
          (err) => console.error("Copy failed: ", err)
        );
      }
    }

    function toggleExpandCollapse() {
      if (expandCollapseAll) {
        const icon = expandCollapseAll.querySelector("i");
        icon.classList.toggle("fa-expand-alt");
        icon.classList.toggle("fa-compress-alt");
        expandCollapseAll.title = icon.classList.contains("fa-compress-alt") ? "Collapse all" : "Expand all";
      }
    }

    function searchInMeasure(term) {
      if (clearMeasureSearch) clearMeasureSearch.style.display = term ? "block" : "none";
      const activeTab = document.querySelector(".measure-tabs .active");
      let codeElement = null;
      if (!activeTab) return;

      if (activeTab.id === "originalTab" && originalCode) codeElement = originalCode;
      else if (activeTab.id === "expandedTab" && expandedCode) codeElement = expandedCode;
      else if (activeTab.id === "optimizedTab" && document.getElementById("optimizedCode")) codeElement = document.getElementById("optimizedCode");

      if (!codeElement) return;
      const originalContent = codeElement.getAttribute('data-original-content') || codeElement.textContent;
      if (!codeElement.hasAttribute('data-original-content')) {
        codeElement.setAttribute('data-original-content', originalContent);
      }

      if (!term) {
        codeElement.innerHTML = originalContent;
        return;
      }
      const regex = new RegExp(`(${escapeRegExp(term)})`, "gi");
      codeElement.innerHTML = originalContent.replace(regex, '<span class="search-highlight">$1</span>');
    }

    function exportMeasureDefinition() {
      const activeTab = document.querySelector(".measure-tabs .active");
      let textToExport = "";
      let fileName = (measureNameEl && measureNameEl.textContent !== "Select a measure" ? measureNameEl.textContent.replace(/\s+/g, "_") : "measure") + ".dax";
      if (!activeTab) return;

      if (activeTab.id === "originalTab" && originalCode) textToExport = originalCode.textContent;
      else if (activeTab.id === "expandedTab" && expandedCode) textToExport = expandedCode.textContent;
      else if (activeTab.id === "optimizedTab" && document.getElementById("optimizedCode")) textToExport = document.getElementById("optimizedCode").textContent;

      if (textToExport && textToExport !== "Select a measure to view its definition" && textToExport !== "Optimizing..." && textToExport !== "Select a measure to view its optimized definition") {
        const blob = new Blob([textToExport], { type: "text/plain;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        if (window.PowerBIExplorer) window.PowerBIExplorer.showNotification("Definition exported", "success");
      }
    }

    function switchTab(tabName) {
      // Remove active class from all tabs
      const tabs = document.querySelectorAll(".measure-tab");
      tabs.forEach(tab => tab.classList.remove("active"));
      
      // Remove active class from all tab contents
      const contents = document.querySelectorAll(".tab-content");
      contents.forEach(content => content.classList.remove("active"));
      
      // Add active class to selected tab and content
      if (tabName === "original") {
        if (originalTab) originalTab.classList.add("active");
        if (originalDefinition) originalDefinition.classList.add("active");
      } else if (tabName === "expanded") {
        if (expandedTab) expandedTab.classList.add("active");
        if (expandedDefinition) expandedDefinition.classList.add("active");
      }
    }
  });
</script>
{% endblock %}
